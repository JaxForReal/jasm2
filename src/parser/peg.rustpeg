use super::Value;
use super::Command;

#[export]
program -> Vec<Command<'input>>
    = __ prog:(command ++ ";") ";" __ { prog }

#[export]
command -> Command<'input>
    = binary_ops
    / unary_ops
    / label
    / ret
    / jump
    / string_commands
    / data

binary_ops -> Command<'input>
    = __ command:identifier __ l:value __ r:value __ arrow __ dest:value __
    {
        match command {
            "add" => Command::Add(l, r, dest),
            "sub" => Command::Sub(l, r, dest),
            "mul" => Command::Mul(l, r, dest),
            "div" => Command::Div(l, r, dest),
            "and" => Command::Div(l, r, dest),
            "or" => Command::Div(l, r, dest),
            "xor" => Command::Div(l, r, dest),
            "leftshift" => Command::LeftShift(l, r, dest),
            "rightshift" => Command::RightShift(l, r, dest),
            "compare" => Command::Compare(l, r, dest),
            _ => panic!("unidentified command")
        }
    }

unary_ops -> Command<'input>
    = __ command:identifier __ arg:value __ arrow __ dest:value
    {
        match command {
            "invert" => Command::Invert(arg, dest),
            "valueof" => Command::ValueOf(arg, dest),
            _ => panic!("unidentified command")
        }
    }

arrow = "->"

string_commands -> Command<'input>
    = __ command:identifier __ string:identifier __
    {
        match command {
            "call" => Command::Call(string),
            "syscall" => Command::SysCall(string),
            _ => panic!("Unidentified string command")
        }
    }
    
//<label_name>;
label -> Command<'input>
    = __ "<" name:identifier ">" __ { Command::Label(name) }

ret -> Command<'input>
    = __ "ret" __ { Command::Ret }

jump -> Command<'input>
    = __ command:identifier __ val:value __ label:identifier __
    {
        match command {
            "jumpzero" => Command::JumpZero(val, label),
            "jumpnotzero" => Command::JumpNotZero(val, label),
            _ => panic!("unrecognised jump command")
        }
    }

//data value value value value -> dest
//any number of values
data -> Command<'input>
    = __ "data" __ values:(value ++ __) __ arrow __ dest:value { Command::Data(values, dest) }

identifier -> &'input str
    = [a-z_]+ { match_str }

////////////
//WHITESPACE
////////////

__ =
    (whitespace / eol_char / comment)*

comment
  = "//" ( .)* eol_char

whitespace
    = [ \t]+

eol_char
  = [\n\r\u2028\u2029]

///////////////
//NUMBER VALUES
///////////////

#[export]
value -> Value
    = i:integer { Value::U32(i) }
    / "@" v:value { Value::Address(Box::new(v)) }

integer -> u32
    = decimal_integer / binary_integer

decimal_integer -> u32
    = [0-9]+ { match_str.parse::<u32>().unwrap() }

binary_integer -> u32
    = "b" [0-1]+ { u32::from_str_radix(&match_str[1..], 2).unwrap() }