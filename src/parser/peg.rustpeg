use super::{Command, Value};

#[export]
program -> Vec<Command<'input>>
    = __ prog:(command ++ line_sep) line_sep __ { prog }

line_sep = __

#[export]
command -> Command<'input>
    = binary_ops
    / ret
    / unary_ops
    / label
    / jump
    / string_commands
    / data
    / valueof

binary_ops -> Command<'input>
    = __ command:identifier __ l:value __ r:value __ arrow __ dest:value __
    {
        match command {
            "add" => Command::Add(l, r, dest),
            "sub" => Command::Sub(l, r, dest),
            "mul" => Command::Mul(l, r, dest),
            "div" => Command::Div(l, r, dest),
            "and" => Command::Div(l, r, dest),
            "or" => Command::Div(l, r, dest),
            "xor" => Command::Div(l, r, dest),
            "leftshift" => Command::LeftShift(l, r, dest),
            "rightshift" => Command::RightShift(l, r, dest),
            "compare" => Command::Compare(l, r, dest),
            _ => panic!("unidentified command")
        }
    }

//use match here so it is easy to add unary ops
unary_ops -> Command<'input>
    = __ command:identifier __ arg:value __ arrow __ dest:value __
    {
        match command {
            "invert" => Command::Invert(arg, dest),
            _ => panic!("unidentified command")
        }
    }

arrow = "->"

string_commands -> Command<'input>
    = __ command:identifier __ string:identifier __
    {
        match command {
            "call" => Command::Call(string),
            "syscall" => Command::SysCall(string),
            _ => panic!("Unidentified string command: {:?}", command)
        }
    }
    
//<label_name>;
label -> Command<'input>
    = __ "<" name:identifier ">" __ { Command::Label(name) }

ret -> Command<'input>
    = __ "ret" __ { Command::Ret }

jump -> Command<'input>
    = __ command:identifier __ val:value __ label:identifier __
    {
        match command {
            "jumpzero" => Command::JumpZero(val, label),
            "jumpnotzero" => Command::JumpNotZero(val, label),
            _ => panic!("unrecognised jump command")
        }
    }

valueof -> Command<'input>
    = __ val:value __ arrow __ dest:value __ { Command::ValueOf(val, dest) }

data -> Command<'input>
    = __ "data" __ values:(value ++ __) __ arrow __ dest:value __ { Command::Data(values, dest) }
    //a string, where each character is added in a new memory cell, surround with quotes, not zero terminated
    / __ "data" __ "`" characters:(data_string_char+) "`" __ arrow __ dest:value __ { Command::Data(characters, dest) }

data_string_char -> Value
    = !"`" . { Value::U32(match_str.chars().nth(0).unwrap() as u32) }

identifier -> &'input str
    = [a-z_]+ { match_str }

////////////
//WHITESPACE
////////////

__ =
    (comment / eol_char / whitespace / multi_line_comment)*

comment
  = "//" (!eol_char .)*

multi_line_comment
    = "/*" (!"*/" .)* "*/"

whitespace
    = [ \t]+

eol_char
    = [\n\r\u2028\u2029]

///////////////
//NUMBER VALUES
///////////////

#[export]
value -> Value
    = i:integer { Value::U32(i) }
    / "@" v:value { Value::Address(Box::new(v)) }

integer -> u32
    = decimal_integer
    / binary_integer
    / ascii_integer

decimal_integer -> u32
    = [0-9]+ { match_str.parse::<u32>().unwrap() }

binary_integer -> u32
    = "b" [0-1]+ { u32::from_str_radix(&match_str[1..], 2).unwrap() }

ascii_integer -> u32
    = "'" . { match_str.chars().nth(1).unwrap() as u32}